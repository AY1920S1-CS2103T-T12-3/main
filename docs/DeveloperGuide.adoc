= Athletick - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S1-CS2103T-T12-3/main/tree/master

By: `AY1920S1-CS2103T-T12-3`      Since: `Sep 2019`      Licence: `MIT`

== Introduction

This section specifies the purpose of this document and design goals of Athletick.

=== Purpose

This document describes the software architecture and system design of Athletick, a team management desktop application for coaches and team captains of timing-based performance sports. It also includes some of the design considerations for the implementation of Athletick's features.

The intended audience of this document includes the developers and software testers of Athletick.

=== Design goals

Athletick was developed as part of CS2103T, a software engineering module taken in the National University of Singapore. We were tasked to morph a generic https://se-education.org/addressbook-level3/[address book application] that manages contacts into an application that manages something else. At the end of the project, it should be ready to be continued by future developers.

As part of the project constraints, the input to Athletick needs to be primarily Command-Line Interface (CLI). Non-CLI inputs will reduce the suitability of the product to our target users. Taking this into consideration, the following principles guide the design of Athletick:

. **Friendlier Syntax**
+
In order to cater to beginner and experienced users of Athletick, we have provided shorter aliases for our command words. This helps new users to use intuitive and self-explanatory commands, while advanced users can accomplish their tasks more quickly with a shorter command syntax.

. **Optimised Performance**
+
Athletick should be able to hold up to 1000 athletes, attendance and performance records without a noticeable sluggishness in performance for typical usage. To achieve this, we used optimal data structures for storing and retrieval of data.


. **Designer Friendly**
+
As Athletick is intended for future student developers like us to make modifications and extensions to its behaviour, adhering to the high-level design architecture strictly was a necessity. This translates to extensive use of abstractions for code clarity. Additionally, we provided Javadoc comments for our classes and methods for developers to understand how they work.

== Setting up

Refer to the guide <<SettingUp#, here>>.

== System design

This section introduces the high-level design of Athletick and gives you a basic understanding of how each component operates and interacts with one another.

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[width=400]

The *_Architecture Diagram_* given above explains the high-level design of Athletick. Given below is a quick overview of each component.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: Displays the UI of Athletick.
* <<Design-Logic,*`Logic`*>>: Executes commands from the user.
* <<Design-Model,*`Model`*>>: Holds the data of Athletick in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (refer to the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component Interactions for `delete 1` Command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<Person>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `Address Book`, which `Person` can reference. This would allow `Address Book` to only require one `Tag` object per unique `Tag`, instead of each `Person` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Athletick data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented. We have included our design considerations for you to understand our decision making processes.

=== Training & Attendance feature

To facilitate management of training sessions, the `Model` stores the `Attendance` of training sessions.

image::attendance_class_diagram.png[]

==== Attendance

The attendance of players is managed using an `Attendance` class.
`Attendance` contains a list of training sessions as it is used to calculate the attendance rate of an individual by looking at all trainings.
Whenever a training is added, the model adds this training to the `Attendance` using a `TrainingCommand`.

==== Training

The Training class contains a date, as well as a HashMap.
The date in the training class represents the date of training session and the HashMap is used to check the attendance of a Person.

We used a `DateTime` class to represent a date of training.
This class is shared across both the `Ui` and backend, allowing us to port training data into the `view calendar` function.

The HashMap uses `Person` objects as keys and a boolean as it’s value.
This is used to check whether a `Person` has attended a training session, indicated by the boolean value attached to a `Person` key.
If a `Person` attended a training session on that day, the value associated with the key will be true, and false if he did not attend.
There were a few design considerations we had in mind for checking attendance of a `Person` but we ultimately decided that using a HashMap was the best solution due to the following requirements:

* Our application allows us to check for the attendance rate of a `Person`. As such, we needed to track both trainings attended and trainings missed.
* As a person could be added into the team after some trainings have taken place,
using trainings attended / total trainings would not give an accurate reflection of a `Person` 's training attendance.

Also, our `select` function shows attendance rate of a `Person` and a HashMap provides the fastest access time to check whether a `Person` attended a training session.

=== Performance feature

=== Calendar feature

The calendar feature allows users to view training and performance records entered into Athletick on a specific date.

==== Implementation

==== Design considerations

=== Select feature
==== Implementation
The select feature is facilitated by `SelectCommand` class. It extends `Command` and parses the arguments using
`SelectCommandParser`. It implements the one operation:

* `CommandResult#execute()` - Executes the selectCommand which returns the person selected to be displayed in the UI.

Other operations that were implemented to aid the `SelectCommand` feature are:

* `Model#selectPerson()` -- Returns the person that was stored.
* `Model#storePerson(Person)` -- Stores the person that was selected.
* `Logic#getPerson()` -- Retrieves the person that was selected to display their personal information in the UI.

These operations are exposed in the Model interface as `Model#selectPerson()` and `Model#storePerson
(Person)` and in the Logic interface as `Logic#getPerson()`.

An example usage scenario is given below which elaborates how the select command works at each step.

Step 1. The user executes the `select 3` command to display the personal information of the 3rd person in the address
book. When the command is executed, the person selected at the specified index will be stored in ModelManager as
`selectedPerson` using the operation `Model#storePerson(Person)`.
//image

Step 2. After the command has been executed, the selected person is retrieved in the MainWindow class. It checks
whether a person has been selected and displays the selected person's personal information.
//snippet and image

The implementation was done this way because the Ui component interacts with both the Logic and Model component.
Firstly, the Ui component takes in the input from the user and allows the Logic component to parse the argument.
After the argument has been parsed, the person is stored in the Model component which houses most of the data of the
app. The Ui listens for any changes made to the Model data, and updates the Ui to display the selected person.

==== Design considerations

===== Aspect: In what way is the personal information of the selected person going to be displayed

* Alternative 1 (current choice): Displaying it in a feature box.
** Pros: Minimises the use of mouse and is in line with the other features that is utilizing the feature box.
** Cons: Aesthetic is not as good compared to the other alternatives.
* Alternative 2: Displaying it in a tab form.
** Pros: Looks more organised compared to the other alternatives
** Cons: Not as intuitive to use as mouse has to be used to switch around tabs.
* Alternative 3: Displaying via a pop-up.
** Pros: Looks neater and organised.
** Cons: Increase the use of mouse to close the window and may be distracting to user.

===== Aspect: How to select a person

* Alternative 1 (current choice): Choosing by the index number.
** Pros: Intuitive to use and can be used with other commands such as `FindCommand` and `FilterCommand` to narrow
down the list of people.
** Cons: Additional step of filtering before selecting a person.
* Alternative 2: Choosing by name.
** Pros: Can omit the filtering step and select the person directly.
** Cons: There may be 2 people with the same name and thus result in an error.

=== Undo / Redo feature

=== Filter feature

The filter command enables filtering of athletes based on their tags.
Currently, only filtering by one tag is supported.
Filtering by multiple tags will be available by `v1.2`.

==== Implementation

Filter makes use of a `TagMatchesPredicate` class to determine if the athlete has tags matching the user input.
Given below is the Sequence Diagram to show how filter works, with an example input of filter captain.

image::filter_sequence_diagram.png[]

Once filtering by multiple tags is implemented, the parsing of tag from `AddressBookParser` to `FilterCommandParser` will involve splitting them by spaces and storing the tag queries in a list.
Thereafter, each tag query will be compared against every athlete’s tags to determine if the athlete should be filtered.

However, since currently only filtering by one tag is supported,
the parsing of tag simply involves trimming the tag of white spaces.

Finally, the list shown to the user is updated through `Model#updateFilteredPersonsList()`.

==== Design considerations

===== Aspect: How a tag match is determined

* **Alternative 1 (current choice):** Case-insensitive.
** Pros: More user-friendly.
** Cons: Requires converting tags to lower-case on the back-end.
* **Alternative 2:** Case-sensitive.
** Pros: Allows for more accurate filtering.
** Cons: Difficult for users to search, as generally filtering and searching are case-insensitive.

===== Aspect: How matches for multiple tags are determined

* **Alternative 1:** Exclusive matching.
** Pros: Allows for more accurate filtering.
** Cons: Users get fewer filter results.
* **Alternative 2:** Optional matching.
** Pros: Allows for more flexible searching.
** Cons: Users may get results that they are not interested in.

// tag::undoredo[]
=== [Proposed] Undo/Redo feature
==== Proposed Implementation

The undo/redo mechanism is facilitated by `VersionedAddressBook`.
It extends `AddressBook` with an undo/redo history, stored internally as an `addressBookStateList` and `currentStatePointer`.
Additionally, it implements the following operations:

* `VersionedAddressBook#commit()` -- Saves the current address book state in its history.
* `VersionedAddressBook#undo()` -- Restores the previous address book state from its history.
* `VersionedAddressBook#redo()` -- Restores a previously undone address book state from its history.

These operations are exposed in the `Model` interface as `Model#commitAddressBook()`, `Model#undoAddressBook()` and `Model#redoAddressBook()` respectively.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. The `VersionedAddressBook` will be initialized with the initial address book state, and the `currentStatePointer` pointing to that single address book state.

image::UndoRedoState0.png[]

Step 2. The user executes `delete 5` command to delete the 5th person in the address book. The `delete` command calls `Model#commitAddressBook()`, causing the modified state of the address book after the `delete 5` command executes to be saved in the `addressBookStateList`, and the `currentStatePointer` is shifted to the newly inserted address book state.

image::UndoRedoState1.png[]

Step 3. The user executes `add n/David ...` to add a new person. The `add` command also calls `Model#commitAddressBook()`, causing another modified address book state to be saved into the `addressBookStateList`.

image::UndoRedoState2.png[]

[NOTE]
If a command fails its execution, it will not call `Model#commitAddressBook()`, so the address book state will not be saved into the `addressBookStateList`.

Step 4. The user now decides that adding the person was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoAddressBook()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous address book state, and restores the address book to that state.

image::UndoRedoState3.png[]

[NOTE]
If the `currentStatePointer` is at index 0, pointing to the initial address book state, then there are no previous address book states to restore. The `undo` command uses `Model#canUndoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The following sequence diagram shows how the undo operation works:

image::UndoSequenceDiagram.png[]

NOTE: The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

The `redo` command does the opposite -- it calls `Model#redoAddressBook()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the address book to that state.

[NOTE]
If the `currentStatePointer` is at index `addressBookStateList.size() - 1`, pointing to the latest address book state, then there are no undone address book states to restore. The `redo` command uses `Model#canRedoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 5. The user then decides to execute the command `list`. Commands that do not modify the address book, such as `list`, will usually not call `Model#commitAddressBook()`, `Model#undoAddressBook()` or `Model#redoAddressBook()`. Thus, the `addressBookStateList` remains unchanged.

image::UndoRedoState4.png[]

Step 6. The user executes `clear`, which calls `Model#commitAddressBook()`. Since the `currentStatePointer` is not pointing at the end of the `addressBookStateList`, all address book states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `add n/David ...` command. This is the behavior that most modern desktop applications follow.

image::UndoRedoState5.png[]

The following activity diagram summarizes what happens when a user executes a new command:

image::CommitActivityDiagram.png[]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire address book.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.

===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use a list to store the history of address book states.
** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedAddressBook`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.
// end::undoredo[]

=== Adding/editing photo feature
==== Implementation
The sub feature of `AddCommand` and `EditCommand` allows the inclusion of photo for a person. The sub feature is
facilitated by `Photo`.

This sub feature is similar to the other features such as `Name` and `Phone` which has a prefix `i/` followed by the
file name (e.g. `i/default.png`). Prior to adding the photo of a person, the image file that is going to be used has to
be in the `\src\main\resources\images` directory. `Photo` takes in the file name as a `String` and retrieves the
photo to be added or edited from the directory that was mentioned previously.

*File name restriction*
The file name of the images is restricted to alphanumerics only and the file format that will be used is `.png`. This
is done to keep the file name simple.

==== Design Consideration
===== Aspect: Regular expression for the file name
* **Alternative 1 (current choice):** To use alphanumerics only.
** Pros: Keeps it simple without the confusion of special characters.
** Cons:
* **Alternative 2:** Alphanumerics and special characters.
** Pros
** Cons

=== Sort Command

The sort command sorts the displayed list of athletes by alphabetical order. As new athletes are added to the bottom of the list, the sort command is used after to reorder the athlete list.

==== Implementation

The `sort` command makes use of a `PersonComparator` that orders athletes in alphabetical order by comparing their names. The comparison is case-insensitive.

The following sequence diagram shows how the sort operation works:

.Interactions Inside the Logic and Model Components for the `sort` Command
image::SortCommandSequenceDiagram.png[]

Upon completion of the above execution, the displayed list of athletes would immediately display the sorted list.

To support sorting by more parameters (e.g. by height / weight), you can simply create a new class that implements `Comparator` that compares athletes by that parameter instead. After which, you have to edit the `sort` command to support different sort command syntaxes.

==== Design considerations
===== Aspect: When should the athlete list should be sorted
* **Alternative 1 (current choice):** Sort address book after user issues the `sort` command
** Pros: Users are able to view their newly added athletes at the bottom of the list which is more user-friendly especially when the list of athletes is very long. Allows future expansion to sort by other methods (e.g. performance scores) easily as we only have to create new comparators to order the athletes.
** Cons: Additional overhead required in terms of having to create an additional command for users to issue.

* **Alternative 2:** Sort address book persistently in alphabetical order
** Pros: Sorting is automated
** Cons: The list is unable to be sorted by other methods (e.g. attendance rate) unless we implement alternative 1 so the alternative 2 is more limited.

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* Team coaches for time-based, competitive sports
* Has a need to manage a significant number of team members
* Prefer desktop apps over other types
* Can type fast
* Prefers typing over mouse input
* Is reasonably comfortable using CLI apps

*Value proposition*: Manage team details faster and more accurately than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="90%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |Team coach |Input attendance of my team  |Keep track of their attendance rate and commitment level

|`* * *` |Team coach |Track performance of my team |Know how to help them improve

|`* * *` |Careless user |Undo my previous commands |Redo any mistakes

|`* * *` |Team coach |Assign tags to my team members |Differentiate roles of team members

|`* *` |Team coach |See all past and scheduled training sessions |Plan better to prepare for competitions

|`*` |Coach who wants fit players |Filter players by overweight BMIs |Single them out and get them to lose weight
|=======================================================================

_{More to be added}_

[appendix]
== Use Cases

(For all use cases below, the *System* is  `Athletick` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== System: Athletick

[discrete]
=== UC1 - Marking attendance of players

Actor: User

*MSS*

1. User requests to list persons
2. Athletick shows a list of persons
3. User keys in players who attended training
4. Athletick saves the training session
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. Athletick shows an error message.
+
Use case resumes at step 2.

[discrete]
=== UC2 - Delete person

Actor: User

*MSS*

1. User requests to list persons
2. Athletick shows a list of persons
3. User requests to delete a specific person in the list
4. Athletick deletes the person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. Athletick shows an error message.
+
Use case resumes at step 2.

[discrete]
=== UC3 - Key in Performance of a Player
Actor: User

*MSS*

1. User requests to list persons
2. Athletick shows a list of persons
3. User requests to tag a performance to a specific person in the list
4. Athletick updates the player’s performances
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. Athletick shows an error message.
+
* 3b. Input event does not exist
+
** 3b1. Athletick shows an error message
* 3c. Timing is invalid
+
** 3c1. Athletick shows an error message

+
Use case resumes at step 2.

[discrete]
=== UC4 - View a player’s profile

Actor: User

*MSS*

1. User requests to list persons
2. Athletic shows a list of persons
3. User request to select a specific person in the list
4. Athletick shows the profile of the person

+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. Athletick shows an error message.
+
Use case resumes at step 2.

[discrete]
=== UC5 - Add a person

Actor: User

*MSS*

1. User keys in details of person to be added
2. Person is added to the list
+
Use case ends.

*Extensions*

* 1a. Details are invalid (eg. not all fields are filled up)
+
[none]
** 1a1. Athletick shows an error message.
+
Use case ends.

* 1b. Person has already been added
+
[none]
** 1b1. Athletick shows an error message.
+
Use case ends.

[discrete]

[discrete]
=== UC6 - Undo a command

Actor: User

*MSS*

1. User calls for undo
2. Most recent command is undone
+
Use case ends.

*Extensions*

* 1a. There are no tasks to be undone.
+
[none]
** 1a1. Athletick shows an error message.
+
Use case ends

* 1b. The most recent command cannot be undone.
+
[none]
** 1b1. Athletick shows the most recent command that can be undone and undo
+
Use case ends.

[discrete]
=== UC7 - Redo a command

Actor: User

*MSS*

1. User calls for redo
2. Undo command is redone
+
Use case ends.

*Extensions*

[none]
* 1a. No Redo Command to be redone
+
[none]
** 1a1. Athletick shows an error message.
+
Use case ends.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[cli]] CLI::
Command line interface (CLI) is a text-based interface that is used to operate software and operating systems while allowing the user to respond to visual prompts by typing single commands into the interface and receiving a reply in the same way.

[[time-base-sports]] Time-base Sports::
Examples of time-based sports are swimming and track & field, where performance can be measured in terms of time or distance.

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
